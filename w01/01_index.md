# Index란?
### Index란?
 데이터베이스 테이블 검색 성능을 높여주는 자료구조.

특정 컬럼에 인덱스를 생성하면, 그 컬럼의 데이터들을 오름차순으로 **정렬**하여 별도의 메모리공간에 **물리적 주소**와 함께 저장된다.
<br>
### Index의 생성
``` 
CREATE INDEX [index name] ON [table name]([column name]);
```

<hr>
# Index의 장점
### 1. 조회 성능 향상

테이블 내 데이터들은 순서가 없이 저장되기 때문에 `WHERE`절로 조회할 때 처음부터 마지막 레코드까지 Full Scan 해야한다.

하지만 Index가 생성되어 있는 컬럼을 기준으로 조회하면 정렬되어 있는 Index의 데이터를 빠르게 조회할 수 있다.

특히 Index의 데이터는 **Balanced Binary Search Tree(균형이진탐색트리) [그중에도 특히 B Tree나 B+Tree]** 에 저장되기 때문에 O(logN)의 시간복잡도로 조회할 수 있다. 

그리고 그렇게 찾은 인덱스 값으로 데이터의 물리주소를 곧바로 찾아 조회할 수 있다.


> - 참고
>  B-Tree -> Balanced Binary Search Tree의 일종이며 한 노드에 데이터가 여러개 들어갈 수 있다.

<br>
### 2. 정렬 성능 향상

Index의 값은 이미 정렬되어있기 때문에 `ORDER BY`절의 수행 성능이 상당히 향상된다.

<br>
### 3. MIN, MAX 성능 향상
정렬과 마찬가지로 `MIN, MAX` 수행 성능도 향상된다.


<hr>
# Index의 단점
### 1. DML 성능 저하
CRUD중 CUD 수행 시 원본테이블에 데이터를 변경해야하고, 인덱스 테이블의 데이터도 같이 변경해야한다. 즉, 두번의 작업이 필요하다.

특히 인덱스 테이블의 값을 수정할 때 정렬도 수행해야하기 때문에 성능을 저하시킬 수 있다.

<br>
### 2. 추가 저장공간 필요
인덱스를 생성하면 데이터베이스의 약 **10%** 에 해당하는 저장공간이 필요하다.

즉 인덱스가 과도하게 생성되면 조회성능은 개선될 수 있으나, 전체적인 DB성능이 저하될 수 있다.

<hr>

# Index 생성 시 고려 사항
### 1. 카디널리티 (Cardinality)
> * 카디널리티: 전체 행에 대한 특정 컬럼의 중복 수치
>    - Unique할 수록 카디널리티는 높다.

카디널리티가 높을수록 Index 생성하기에 좋다. 즉, 한 컬럼이 갖고있는 값의 중복되는 정도가 낮을 수록 좋다.
<br>
### 2. 선택도(Selectivity)
> * 선택도: 데이터 집합에서 특정 값을 얼마나 잘 선택할 수 있는지에 대한 지표이다.
>    - 선택도 = 특정 값의 개수 / 테이블의 총 레코드 수 * 100
>    - ex) 데이터가 5개 들어있는 테이블의 성별 컬럼의 선택도 = 2 / 5 * 100 = 40%

선택도가 낮을수록 Index 생성하기 좋으며, 10~15% 정도가 적당하다.
<hr>
# Composite Index(복합인덱스)
### 1. 복합인덱스란?
 기준이 되는 컬럼이 하나가 아닌 인덱스를 의미하며, 결합인덱스 라고도 칭한다.

<br>
### 2. 복합인덱스의 생성
``` 
CREATE INDEX [index name] ON [table name]([column name 01], [column name 02] ... );
```
<br>
### 3. 복합인덱스에서 컬럼의 순서
#### 1) 순서가 중요한 이유
복합인덱스는 생성시 결정된 순서가 중요하다.

`CREATE INDEX tmp_idx ON tmp_table(A, B, C, D);`

위와 같이 인덱스를 생성했을 때 인덱스 테이블에 들어가는 데이터의 정렬순서는 쿼리에 들어있는 순서 **[A -> B -> C]** 가 된다.
즉, A로 먼저 정렬한 다음 B로 정렬하고, 마지막으로 C로 정렬한다.

따라서 데이터를 찾을 때도 A로 먼저 찾은 다음 B로 찾고 마지막으로 C로 찾는다.
<br>

#### 2) 복합인덱스의 동작
- `WHERE`절에서 복합인덱스의 첫번째 컬럼을 사용하지 않으면, 그 인덱스는 거의 사용되지 않는다.
- 결합인덱스에서 `=, IN`이 아닌 조건을 만나면, 그 뒤에서는 인덱스를 타지 않는다.
```
SELECT *
FROM tmp_table
WHERE A = 'A'
  AND B = 'B'
  AND C BETWEEN 1 AND 10
  AND D = 'D'
```
위와 같은 쿼리에서 C컬럼을 대상으로 `=, IN`이 아닌 `BETWEEN`을 사용했기 때문에 D컬럼은 인덱스를 타지 않는다.

<hr>
# Index에 대한 고찰
> 최근 회사에서 서비스 예약접수리스트 조회 시 기간조건을 접수일시 기준이 아니라 예약일시 기준으로 변경해달라는 요건이 있었다.
그 때, 단순히 예약일시로 조회하게 변경했더니 쿼리수행시간이 너무 길어서 실패했다.
여기에 접수타입(예약인지, 그냥 접수건인지) + 예약일시으로 인덱스를 만들면 어땠을지 싶다.

> 그런데 시간으로 인덱스를 만들면 선택도가 지나치게 낮아지지 않을지 염려가 되기도 한다. 
차라리 예약일자 컬럼을 만들어서 접수타입 + 예약일자로 인덱스를 만들면 더 나을것 같기도하다. 

